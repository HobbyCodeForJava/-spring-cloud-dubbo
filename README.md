# spring-cloud dubbo
微服务技术选型参考
spring-cloud与dubbo区别：
服务注册的粒度不同：springcloud或k8s的注册的服务就是微服务应用本身，一个应用作为一个服务整体注册，发现服务后可以请求这个应用的controller中的任意方法；dubbo注册的服务是一个service接口，一个微服务应用可能会注册大量的接口类，没有注册的Service不能被外部调用，dubbo需要把接口和参数pojo打成接口包，作为消费方的约束。调用的层次不同：dubbo作为RPC方式，调用的是Service，通常Spring开发中的Service接口，可以直接作为服务注册（实际上还是要规划一下对外服务的方法和参数，给其它微服务调用的方法和参数和微服务本身的通常不一样，对外参数通常用VO，微服务本身参数经常用DO处理增删改查等操作，所以还是单独写比较好），在controller方法中写Service调用，与调用本地服务写法是一样的。springcloud是REST方式，实际就是访问controller中的方法，在spring里用restTemplate来方便地调用（比httpClient简单很多），但这种写法与调本地方法完全不同。消费端可以用feign伪装成一个接口，这是一种额外的开发任务。

dubbo能控制哪些服务开放哪些不开放，有强的方法参数约束，这一点很好，但是也要考虑哪些服务开放等规则，针对外部调用进行设计增加了一定复杂度。springcloud与正常前端请求一样可以请求任何方法不受限制，几乎不需要考虑针对服务调用的专门设计，这与服务本身对前端的调用需求是一样的。理念上更简单，限制某些方法访问可以通过通用的权限或路由规则来做。但是resttemplate返回的是字符串需要转化为对象，这种转化如果没有接口包则缺乏约束，通常靠swagger文档来规范（也可以，很简单），但是复杂对象时，仍然希望能实现良好的转换，可以加上feign在消费端模似成接口，这样加一组接口包后，其实和dubbo差不多，都是一种针对服务调用的规划设计，复杂度上其实差不多。因为Dubbo是强约束的，接口包的版本管理和分发就是一个问题，springcloud可以不同接口包但缺乏规范约束，加上feign有了约束也存在包版本和分发问题。性能上Dubbo只是好一点点而已，影响不大，其它扩展的功能各自都有解决方案。springcloud的REST方式与编程语言无关，对多语言多平台团队更适合，dubbo就是java的方案。我们选择的是dubbo，看重的是Dubbo本地调用和远程调用写法相同这一点，微服务部署更复杂，其实非互联网项目微服务架构并不是必须的，我们希望部署上能够更灵活，既可以部署为单体，也可以灵活地部署为几个、几十个微服务，能找到注入Bean就直接本地调用，找不到就用Dubbo来调用远程服务，这一点springcloud不行，只能一开始就规划好微服务组成。两种混用也可以，内部的应用（原来单体拆开后的微服务）之间用dubbo，高性能内部调用，写法和本地相同；对第三方异构应用可以注册为springcloud服务，及调用第三方的服务。
